#!/usr/bin/env node
"use strict";

const puppeteer = require("puppeteer");
const fs = require("fs");

function getDateTimeString() {
  let date_time = new Date();

  let date = ("0" + date_time.getDate()).slice(-2);
  let month = ("0" + (date_time.getMonth() + 1)).slice(-2);
  let year = date_time.getFullYear();
  let hours = ("0" + date_time.getHours()).slice(-2);
  let minutes = ("0" + date_time.getMinutes()).slice(-2);
  let seconds = ("0" + date_time.getSeconds()).slice(-2);

  return `${year}-${month}-${date}+${hours}:${minutes}:${seconds}`;
}

function outputStats(minifiedStats) {
  const statJson = JSON.stringify(minifiedStats, null, 4);
  const dateTime = getDateTimeString();
  const statOutput = fs.createWriteStream(
    __dirname.replace("scripts", "data") + `/puppeteer-${dateTime}.json`
  );
  statOutput.write(statJson);
  statOutput.write("\n");
  statOutput.end();
}

/**
 * üöß Automatically generated by Copilot üöß üôè üôè üôè
 * Todo: return a different resource type for tracking pixels
 * Reconsider approach and test against a diverse set of websites
 */
function getAssetTypeFromResource(resource) {
  if (resource.initiatorType === "navigation") return "document";

  const url = resource.name;

  if (url.endsWith(".css")) return "stylesheet";
  if (url.endsWith(".js")) return "script";
  if (url.endsWith(".png")) return "image";
  if (url.endsWith(".jpg")) return "image";
  if (url.endsWith(".jpeg")) return "image";
  if (url.endsWith(".webp")) return "image";
  if (url.endsWith(".gif")) return "image";
  if (url.endsWith(".svg")) return "image";
  if (url.endsWith(".woff")) return "font";
  if (url.endsWith(".woff2")) return "font";
  if (url.endsWith(".ttf")) return "font";
  if (url.endsWith(".otf")) return "font";
  if (url.endsWith(".eot")) return "font";
  if (url.endsWith(".ico")) return "image";
  if (url.endsWith(".mp4")) return "media";
  if (url.endsWith(".webm")) return "media";
  if (url.endsWith(".ogg")) return "media";
  if (url.endsWith(".mp3")) return "media";
  if (url.endsWith(".wav")) return "media";
  if (url.endsWith(".json")) return "json";
  if (url.endsWith(".xml")) return "xml";
  if (url.endsWith(".txt")) return "text";
  if (url.endsWith(".pdf")) return "pdf";

  if (resource.initiatorType === "xmlhttprequest") return "xhr";
  if (resource.initiatorType === "fetch") return "fetch";
  if (resource.initiatorType === "img") return "image";
  if (resource.initiatorType === "script") return "script";
  if (resource.initiatorType === "css") return "stylesheet";
  if (resource.initiatorType === "beacon") return "beacon";

  console.log("No resource type found for:");
  console.log(resource);
}

function parsePerformanceResources(resources) {
  let output = {};
  output.requests = [];

  for (let i = 0; i < resources.length; i++) {
    let resource = resources[i];

    if (
      resource.entryType === "navigation" ||
      resource.entryType === "resource"
    ) {
      const resourceType = getAssetTypeFromResource(resource);

      output.requests.push({
        url: resource.name,
        resourceType: resourceType,
        transferSize: resource.transferSize,
      });
    }
  }

  return output;
}

(async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  const client = await page.target().createCDPSession();
  await client.send("Network.setCacheDisabled", {
    cacheDisabled: true,
  });
  await page.setCacheEnabled(false);

  // domContentLoaded doesn't allow secondary scripts to load
  // networkIdle waits for 500ms of no network activity
  // 250ms seems good enough for our purposes - test this on different websites!
  await Promise.all([
    page.goto("https://torchbox.com/careers/jobs", {
      waitUntil: "domcontentloaded",
    }),
    page.waitForNetworkIdle({ idleTime: 250 }),
  ]);

  const performanceEntries = JSON.parse(
    await page.evaluate(() => JSON.stringify(window.performance.getEntries()))
  );

  const results = parsePerformanceResources(performanceEntries);
  outputStats(results);
  console.log(results);

  await browser.close();
})();
